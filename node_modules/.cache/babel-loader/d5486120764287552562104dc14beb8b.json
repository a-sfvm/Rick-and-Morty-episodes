{"ast":null,"code":"export const uppercase = str => str.toUpperCase();\nexport const callOrIdentity = value => {\n  return typeof value === `function` ? value() : value;\n};\nexport const zip = (a, b) => a.map((k, i) => [k, b[i]]);\nexport const HeadersInitToPlainObject = headers => {\n  let oHeaders = {};\n\n  if (headers instanceof Headers) {\n    oHeaders = HeadersInstanceToPlainObject(headers);\n  } else if (Array.isArray(headers)) {\n    headers.forEach(_ref => {\n      let [name, value] = _ref;\n\n      if (name && value !== undefined) {\n        oHeaders[name] = value;\n      }\n    });\n  } else if (headers) {\n    oHeaders = headers;\n  }\n\n  return oHeaders;\n};\nexport const HeadersInstanceToPlainObject = headers => {\n  const o = {};\n  headers.forEach((v, k) => {\n    o[k] = v;\n  });\n  return o;\n};\nexport const tryCatch = fn => {\n  try {\n    const result = fn();\n\n    if (isPromiseLikeValue(result)) {\n      return result.catch(error => {\n        return errorFromMaybeError(error);\n      });\n    }\n\n    return result;\n  } catch (error) {\n    return errorFromMaybeError(error);\n  }\n};\n/**\n * Ensure that the given value is an error and return it. If it is not an error than\n * wrap it in one, passing the given value as the error message.\n */\n\nexport const errorFromMaybeError = maybeError => {\n  if (maybeError instanceof Error) return maybeError;\n  return new Error(String(maybeError));\n};\nexport const isPromiseLikeValue = value => {\n  return typeof value === `object` && value !== null && `then` in value && typeof value.then === `function` && `catch` in value && typeof value.catch === `function` && `finally` in value && typeof value.finally === `function`;\n};\nexport const casesExhausted = value => {\n  throw new Error(`Unhandled case: ${String(value)}`);\n};\nexport const isPlainObject = value => {\n  return typeof value === `object` && value !== null && !Array.isArray(value);\n};\nexport const entries = obj => Object.entries(obj);\nexport const values = obj => Object.values(obj);\nexport const mapValues = (object, fn) => {\n  return Object.fromEntries(Object.entries(object).map(_ref2 => {\n    let [key, value] = _ref2;\n    return [key, fn(value, key)];\n  }));\n};\nexport const lowerCaseFirstLetter = s => {\n  return s.charAt(0).toLowerCase() + s.slice(1);\n};\nexport function assertArray(v) {\n  if (!Array.isArray(v)) throw new Error(`Expected array. Got: ${String(v)}`);\n}\nexport function assertObject(v) {\n  if (v === null || typeof v !== `object`) throw new Error(`Expected object. Got: ${String(v)}`);\n}\nexport const capitalizeFirstLetter = string => string.charAt(0).toUpperCase() + string.slice(1);\nexport const createDeferred = options => {\n  let isResolved = false;\n  let resolve;\n  let reject;\n  const promise = new Promise(($resolve, $reject) => {\n    resolve = $resolve;\n    reject = $reject;\n  });\n  return {\n    promise,\n    isResolved: () => isResolved,\n    resolve: value => {\n      isResolved = true;\n\n      if (options?.strict && isResolved) {\n        throw new Error(`Deferred is already resolved. Attempted to resolve with: ${JSON.stringify(value)}`);\n      }\n\n      resolve(value);\n    },\n    reject: error => reject(error)\n  };\n};\nexport const debug = function () {\n  if (process.env[`DEBUG`]) {\n    console.log(...arguments);\n  }\n};\nexport const debugSub = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, subArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      subArgs[_key2] = arguments[_key2];\n    }\n\n    debug(...args, ...subArgs);\n  };\n};\nexport const partitionErrors = array => {\n  const errors = [];\n  const values = [];\n\n  for (const item of array) {\n    if (item instanceof Error) {\n      errors.push(item);\n    } else {\n      values.push(item);\n    }\n  }\n\n  return [values, errors];\n};","map":{"version":3,"mappings":"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","names":["uppercase","str","toUpperCase","callOrIdentity","value","zip","a","b","map","k","i","HeadersInitToPlainObject","headers","oHeaders","Headers","HeadersInstanceToPlainObject","Array","isArray","forEach","name","undefined","o","v","tryCatch","fn","result","isPromiseLikeValue","catch","error","errorFromMaybeError","maybeError","Error","String","then","finally","casesExhausted","isPlainObject","entries","obj","Object","values","mapValues","object","fromEntries","key","lowerCaseFirstLetter","s","charAt","toLowerCase","slice","assertArray","assertObject","capitalizeFirstLetter","string","createDeferred","options","isResolved","resolve","reject","promise","Promise","$resolve","$reject","strict","JSON","stringify","debug","process","env","console","log","debugSub","args","subArgs","partitionErrors","array","errors","item","push"],"sources":["/Users/admin/code/language-finder/node_modules/graphql-request/src/lib/prelude.ts"],"sourcesContent":["/* eslint-disable */\nexport type RemoveIndex<T> = {\n  [K in keyof T as string extends K ? never : number extends K ? never : K]: T[K]\n}\n\nexport const uppercase = <S extends string>(str: S): Uppercase<S> => str.toUpperCase() as Uppercase<S>\n\nexport const callOrIdentity = <T>(value: MaybeLazy<T>) => {\n  return typeof value === `function` ? (value as () => T)() : value\n}\n\nexport type MaybeLazy<T> = T | (() => T)\n\nexport const zip = <A, B>(a: A[], b: B[]): [A, B | undefined][] => a.map((k, i) => [k, b[i]])\n\nexport const HeadersInitToPlainObject = (headers?: HeadersInit): Record<string, string> => {\n  let oHeaders: Record<string, string> = {}\n\n  if (headers instanceof Headers) {\n    oHeaders = HeadersInstanceToPlainObject(headers)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(([name, value]) => {\n      if (name && value !== undefined) {\n        oHeaders[name] = value\n      }\n    })\n  } else if (headers) {\n    oHeaders = headers\n  }\n\n  return oHeaders\n}\n\nexport const HeadersInstanceToPlainObject = (headers: Response['headers']): Record<string, string> => {\n  const o: Record<string, string> = {}\n  headers.forEach((v, k) => {\n    o[k] = v\n  })\n  return o\n}\n\nexport const tryCatch = <$Return, $Throw extends Error = Error>(\n  fn: () => $Return,\n): $Return extends Promise<any> ? Promise<Awaited<$Return> | $Throw> : $Return | $Throw => {\n  try {\n    const result = fn() as any\n    if (isPromiseLikeValue(result)) {\n      return result.catch((error) => {\n        return errorFromMaybeError(error)\n      }) as any\n    }\n    return result\n  } catch (error) {\n    return errorFromMaybeError(error) as any\n  }\n}\n\n/**\n * Ensure that the given value is an error and return it. If it is not an error than\n * wrap it in one, passing the given value as the error message.\n */\nexport const errorFromMaybeError = (maybeError: unknown): Error => {\n  if (maybeError instanceof Error) return maybeError\n  return new Error(String(maybeError))\n}\n\nexport const isPromiseLikeValue = (value: unknown): value is Promise<unknown> => {\n  return (\n    typeof value === `object`\n    && value !== null\n    && `then` in value\n    && typeof value.then === `function`\n    && `catch` in value\n    && typeof value.catch === `function`\n    && `finally` in value\n    && typeof value.finally === `function`\n  )\n}\n\nexport const casesExhausted = (value: never): never => {\n  throw new Error(`Unhandled case: ${String(value)}`)\n}\n\nexport const isPlainObject = (value: unknown): value is Record<string, unknown> => {\n  return typeof value === `object` && value !== null && !Array.isArray(value)\n}\n\nexport const entries = <T extends Record<string, any>>(obj: T) => Object.entries(obj) as [keyof T, T[keyof T]][]\n\nexport const values = <T extends Record<string, unknown>>(obj: T): T[keyof T][] => Object.values(obj) as T[keyof T][]\n\n// dprint-ignore\nexport type Exact<$Value, $Constraint> =\n  (\n    $Value extends unknown  ? $Constraint extends $Value   ?  {} extends $Value    ?  $Constraint :\n                                                                                      { [K in keyof $Value]: Exact<$Value[K], $Constraint[K]> } :\n                                                              $Constraint :\n                              never\n  )\n  | ($Value extends Narrowable ? $Value : never)\n\n// dprint-ignore\n// export type ExactObjectNonEmpty<$Value, $Constraint> =\n//   (\n//     $Value extends unknown  ? $Constraint extends $Value   ?  keyof $Value extends never  ? ({ 'TypeScript Error: You must supply at least one key.': true } & $Constraint)  :\n//                                                                                             { [K in keyof $Value]: Exact<$Value[K], $Constraint[K]> } :\n//                                                               $Constraint :\n//                               never\n//   )\n//   | ($Value extends Narrowable ? $Value : never)\n\nexport type Narrowable = string | number | bigint | boolean | []\n\nexport type Letter = LetterLower | LetterUpper\n\nexport type Digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n\nexport type LetterLower =\n  | 'a'\n  | 'b'\n  | 'c'\n  | 'd'\n  | 'e'\n  | 'f'\n  | 'g'\n  | 'h'\n  | 'i'\n  | 'j'\n  | 'k'\n  | 'l'\n  | 'm'\n  | 'n'\n  | 'o'\n  | 'p'\n  | 'q'\n  | 'r'\n  | 's'\n  | 't'\n  | 'u'\n  | 'v'\n  | 'w'\n  | 'x'\n  | 'y'\n  | 'z'\nexport type LetterUpper =\n  | 'A'\n  | 'B'\n  | 'C'\n  | 'D'\n  | 'E'\n  | 'F'\n  | 'G'\n  | 'H'\n  | 'I'\n  | 'J'\n  | 'K'\n  | 'L'\n  | 'M'\n  | 'N'\n  | 'O'\n  | 'P'\n  | 'Q'\n  | 'R'\n  | 'S'\n  | 'T'\n  | 'U'\n  | 'V'\n  | 'W'\n  | 'X'\n  | 'Y'\n  | 'Z'\n\nexport type StringNonEmpty = `${Letter}${string}`\n\nexport type MaybeList<T> = T | T[]\n\nexport type NotEmptyObject<T> = keyof T extends never ? never : T\n\nexport type Values<T> = T[keyof T]\n\nexport type GetKeyOr<T, Key, Or> = Key extends keyof T ? T[Key] : Or\n\nexport type As<T, U> = U extends T ? U : never\n\nexport type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never\n\nexport type LastOf<T> = UnionToIntersection<T extends any ? () => T : never> extends () => infer R ? R : never\n\n// TS4.0+\nexport type Push<T extends any[], V> = [...T, V]\n\n// TS4.1+\nexport type UnionToTuple<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? []\n  : Push<UnionToTuple<Exclude<T, L>>, L>\n\nexport type CountKeys<T> = keyof T extends never ? 0 : UnionToTuple<keyof T>['length']\nexport type IsMultipleKeys<T> = IsMultiple<CountKeys<T>>\nexport type IsMultiple<T> = T extends 0 ? false : T extends 1 ? false : true\n\nexport type ExcludeNull<T> = Exclude<T, null>\n\nexport const mapValues = <\n  $Obj extends Record<string, any>,\n  $Fn extends (value: $Obj[keyof $Obj], key: keyof $Obj) => any,\n>(\n  object: $Obj,\n  fn: $Fn,\n): Record<keyof $Obj, ReturnType<$Fn>> => {\n  return Object.fromEntries(\n    Object.entries(object).map(([key, value]) => {\n      return [key, fn(value, key)]\n    }),\n  ) as Record<keyof $Obj, ReturnType<$Fn>>\n}\n\nexport type SetProperty<$Obj extends object, $Prop extends keyof $Obj, $Type extends $Obj[$Prop]> =\n  & Omit<$Obj, $Prop>\n  & { [_ in $Prop]: $Type }\n\nexport const lowerCaseFirstLetter = (s: string) => {\n  return s.charAt(0).toLowerCase() + s.slice(1)\n}\n\nexport function assertArray(v: unknown): asserts v is unknown[] {\n  if (!Array.isArray(v)) throw new Error(`Expected array. Got: ${String(v)}`)\n}\n\nexport function assertObject(v: unknown): asserts v is object {\n  if (v === null || typeof v !== `object`) throw new Error(`Expected object. Got: ${String(v)}`)\n}\n\nexport type StringKeyof<T> = keyof T & string\n\nexport type MaybePromise<T> = T | Promise<T>\n\nexport const capitalizeFirstLetter = (string: string) => string.charAt(0).toUpperCase() + string.slice(1)\n\nexport type SomeAsyncFunction = (...args: unknown[]) => Promise<unknown>\n\nexport type SomeMaybeAsyncFunction = (...args: unknown[]) => MaybePromise<unknown>\n\nexport type Deferred<T> = {\n  promise: Promise<T>\n  isResolved: () => boolean\n  resolve: (value: T) => void\n  reject: (error: unknown) => void\n}\n\nexport const createDeferred = <$T>(options?: { strict?: boolean }): Deferred<$T> => {\n  let isResolved = false\n  let resolve: (value: $T) => void\n  let reject: (error: unknown) => void\n\n  const promise = new Promise<$T>(($resolve, $reject) => {\n    resolve = $resolve\n    reject = $reject\n  })\n\n  return {\n    promise,\n    isResolved: () => isResolved,\n    resolve: (value) => {\n      isResolved = true\n      if (options?.strict && isResolved) {\n        throw new Error(`Deferred is already resolved. Attempted to resolve with: ${JSON.stringify(value)}`)\n      }\n      resolve(value)\n    },\n    reject: (error) => reject(error),\n  }\n}\n\nexport const debug = (...args: any[]) => {\n  if (process.env[`DEBUG`]) {\n    console.log(...args)\n  }\n}\n\nexport const debugSub = (...args: any[]) => (...subArgs: any[]) => {\n  debug(...args, ...subArgs)\n}\n\nexport type PlusOneUpToTen<n extends number> = n extends 0 ? 1\n  : n extends 1 ? 2\n  : n extends 2 ? 3\n  : n extends 3 ? 4\n  : n extends 4 ? 5\n  : n extends 5 ? 6\n  : n extends 6 ? 7\n  : n extends 7 ? 8\n  : n extends 8 ? 9\n  : n extends 9 ? 10\n  : never\n\nexport type MinusOneUpToTen<n extends number> = n extends 10 ? 9\n  : n extends 9 ? 8\n  : n extends 8 ? 7\n  : n extends 7 ? 6\n  : n extends 6 ? 5\n  : n extends 5 ? 4\n  : n extends 4 ? 3\n  : n extends 3 ? 2\n  : n extends 2 ? 1\n  : n extends 1 ? 0\n  : never\n\nexport type findIndexForValue<value, list extends readonly [any, ...any[]]> = findIndexForValue_<value, list, 0>\ntype findIndexForValue_<value, list extends readonly [any, ...any[]], i extends number> = value extends list[i] ? i\n  : findIndexForValue_<value, list, PlusOneUpToTen<i>>\n\nexport type FindValueAfter<value, list extends readonly [any, ...any[]]> =\n  list[PlusOneUpToTen<findIndexForValue<value, list>>]\n\nexport type ValueOr<value, orValue> = value extends undefined ? orValue : value\n\nexport type FindValueAfterOr<value, list extends readonly [any, ...any[]], orValue> = ValueOr<\n  list[PlusOneUpToTen<findIndexForValue<value, list>>],\n  orValue\n>\n\nexport type GetLastValue<T extends readonly [any, ...any[]]> = T[MinusOneUpToTen<T['length']>]\n\nexport type IsLastValue<value, list extends readonly [any, ...any[]]> = value extends GetLastValue<list> ? true : false\n\nexport type Include<T, U> = T extends U ? T : never\n\nexport const partitionErrors = <T>(array: T[]): [Exclude<T, Error>[], Include<T, Error>[]] => {\n  const errors: Include<T, Error>[] = []\n  const values: Exclude<T, Error>[] = []\n  for (const item of array) {\n    if (item instanceof Error) {\n      errors.push(item as any)\n    } else {\n      values.push(item as any)\n    }\n  }\n  return [values, errors]\n}\n"]},"metadata":{},"sourceType":"module"}