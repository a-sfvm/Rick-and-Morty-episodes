{"ast":null,"code":"import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nconst MAX_LISTS_DEPTH = 3;\nexport function MaxIntrospectionDepthRule(context) {\n  /**\n   * Counts the depth of list fields in \"__Type\" recursively and\n   * returns `true` if the limit has been reached.\n   */\n  function checkDepth(node) {\n    let visitedFragments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object.create(null);\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (node.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = node.name.value;\n\n      if (visitedFragments[fragmentName] === true) {\n        // Fragment cycles are handled by `NoFragmentCyclesRule`.\n        return false;\n      }\n\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        // Missing fragments checks are handled by `KnownFragmentNamesRule`.\n        return false;\n      } // Rather than following an immutable programming pattern which has\n      // significant memory and garbage collection overhead, we've opted to\n      // take a mutable approach for efficiency's sake. Importantly visiting a\n      // fragment twice is fine, so long as you don't do one visit inside the\n      // other.\n\n\n      try {\n        visitedFragments[fragmentName] = true;\n        return checkDepth(fragment, visitedFragments, depth);\n      } finally {\n        visitedFragments[fragmentName] = undefined;\n      }\n    }\n\n    if (node.kind === Kind.FIELD && ( // check all introspection lists\n    node.name.value === 'fields' || node.name.value === 'interfaces' || node.name.value === 'possibleTypes' || node.name.value === 'inputFields')) {\n      // eslint-disable-next-line no-param-reassign\n      depth++;\n\n      if (depth >= MAX_LISTS_DEPTH) {\n        return true;\n      }\n    } // handles fields and inline fragments\n\n\n    if ('selectionSet' in node && node.selectionSet) {\n      for (const child of node.selectionSet.selections) {\n        if (checkDepth(child, visitedFragments, depth)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return {\n    Field(node) {\n      if (node.name.value === '__schema' || node.name.value === '__type') {\n        if (checkDepth(node)) {\n          context.reportError(new GraphQLError('Maximum introspection depth exceeded', {\n            nodes: [node]\n          }));\n          return false;\n        }\n      }\n    }\n\n  };\n}","map":{"version":3,"names":["GraphQLError","Kind","MAX_LISTS_DEPTH","MaxIntrospectionDepthRule","context","checkDepth","node","visitedFragments","Object","create","depth","kind","FRAGMENT_SPREAD","fragmentName","name","value","fragment","getFragment","undefined","FIELD","selectionSet","child","selections","Field","reportError","nodes"],"sources":["/Users/admin/code/language-finder/node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nconst MAX_LISTS_DEPTH = 3;\nexport function MaxIntrospectionDepthRule(context) {\n  /**\n   * Counts the depth of list fields in \"__Type\" recursively and\n   * returns `true` if the limit has been reached.\n   */\n  function checkDepth(node, visitedFragments = Object.create(null), depth = 0) {\n    if (node.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = node.name.value;\n\n      if (visitedFragments[fragmentName] === true) {\n        // Fragment cycles are handled by `NoFragmentCyclesRule`.\n        return false;\n      }\n\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        // Missing fragments checks are handled by `KnownFragmentNamesRule`.\n        return false;\n      } // Rather than following an immutable programming pattern which has\n      // significant memory and garbage collection overhead, we've opted to\n      // take a mutable approach for efficiency's sake. Importantly visiting a\n      // fragment twice is fine, so long as you don't do one visit inside the\n      // other.\n\n      try {\n        visitedFragments[fragmentName] = true;\n        return checkDepth(fragment, visitedFragments, depth);\n      } finally {\n        visitedFragments[fragmentName] = undefined;\n      }\n    }\n\n    if (\n      node.kind === Kind.FIELD && // check all introspection lists\n      (node.name.value === 'fields' ||\n        node.name.value === 'interfaces' ||\n        node.name.value === 'possibleTypes' ||\n        node.name.value === 'inputFields')\n    ) {\n      // eslint-disable-next-line no-param-reassign\n      depth++;\n\n      if (depth >= MAX_LISTS_DEPTH) {\n        return true;\n      }\n    } // handles fields and inline fragments\n\n    if ('selectionSet' in node && node.selectionSet) {\n      for (const child of node.selectionSet.selections) {\n        if (checkDepth(child, visitedFragments, depth)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return {\n    Field(node) {\n      if (node.name.value === '__schema' || node.name.value === '__type') {\n        if (checkDepth(node)) {\n          context.reportError(\n            new GraphQLError('Maximum introspection depth exceeded', {\n              nodes: [node],\n            }),\n          );\n          return false;\n        }\n      }\n    },\n  };\n}\n"],"mappings":"AAAA,SAASA,YAAT,QAA6B,8BAA7B;AACA,SAASC,IAAT,QAAqB,0BAArB;AACA,MAAMC,eAAe,GAAG,CAAxB;AACA,OAAO,SAASC,yBAAT,CAAmCC,OAAnC,EAA4C;EACjD;AACF;AACA;AACA;EACE,SAASC,UAAT,CAAoBC,IAApB,EAA6E;IAAA,IAAnDC,gBAAmD,uEAAhCC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAgC;IAAA,IAAXC,KAAW,uEAAH,CAAG;;IAC3E,IAAIJ,IAAI,CAACK,IAAL,KAAcV,IAAI,CAACW,eAAvB,EAAwC;MACtC,MAAMC,YAAY,GAAGP,IAAI,CAACQ,IAAL,CAAUC,KAA/B;;MAEA,IAAIR,gBAAgB,CAACM,YAAD,CAAhB,KAAmC,IAAvC,EAA6C;QAC3C;QACA,OAAO,KAAP;MACD;;MAED,MAAMG,QAAQ,GAAGZ,OAAO,CAACa,WAAR,CAAoBJ,YAApB,CAAjB;;MAEA,IAAI,CAACG,QAAL,EAAe;QACb;QACA,OAAO,KAAP;MACD,CAbqC,CAapC;MACF;MACA;MACA;MACA;;;MAEA,IAAI;QACFT,gBAAgB,CAACM,YAAD,CAAhB,GAAiC,IAAjC;QACA,OAAOR,UAAU,CAACW,QAAD,EAAWT,gBAAX,EAA6BG,KAA7B,CAAjB;MACD,CAHD,SAGU;QACRH,gBAAgB,CAACM,YAAD,CAAhB,GAAiCK,SAAjC;MACD;IACF;;IAED,IACEZ,IAAI,CAACK,IAAL,KAAcV,IAAI,CAACkB,KAAnB,MAA4B;IAC3Bb,IAAI,CAACQ,IAAL,CAAUC,KAAV,KAAoB,QAApB,IACCT,IAAI,CAACQ,IAAL,CAAUC,KAAV,KAAoB,YADrB,IAECT,IAAI,CAACQ,IAAL,CAAUC,KAAV,KAAoB,eAFrB,IAGCT,IAAI,CAACQ,IAAL,CAAUC,KAAV,KAAoB,aAJtB,CADF,EAME;MACA;MACAL,KAAK;;MAEL,IAAIA,KAAK,IAAIR,eAAb,EAA8B;QAC5B,OAAO,IAAP;MACD;IACF,CAzC0E,CAyCzE;;;IAEF,IAAI,kBAAkBI,IAAlB,IAA0BA,IAAI,CAACc,YAAnC,EAAiD;MAC/C,KAAK,MAAMC,KAAX,IAAoBf,IAAI,CAACc,YAAL,CAAkBE,UAAtC,EAAkD;QAChD,IAAIjB,UAAU,CAACgB,KAAD,EAAQd,gBAAR,EAA0BG,KAA1B,CAAd,EAAgD;UAC9C,OAAO,IAAP;QACD;MACF;IACF;;IAED,OAAO,KAAP;EACD;;EAED,OAAO;IACLa,KAAK,CAACjB,IAAD,EAAO;MACV,IAAIA,IAAI,CAACQ,IAAL,CAAUC,KAAV,KAAoB,UAApB,IAAkCT,IAAI,CAACQ,IAAL,CAAUC,KAAV,KAAoB,QAA1D,EAAoE;QAClE,IAAIV,UAAU,CAACC,IAAD,CAAd,EAAsB;UACpBF,OAAO,CAACoB,WAAR,CACE,IAAIxB,YAAJ,CAAiB,sCAAjB,EAAyD;YACvDyB,KAAK,EAAE,CAACnB,IAAD;UADgD,CAAzD,CADF;UAKA,OAAO,KAAP;QACD;MACF;IACF;;EAZI,CAAP;AAcD"},"metadata":{},"sourceType":"module"}