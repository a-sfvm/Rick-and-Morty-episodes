{"ast":null,"code":"import { ACCEPT_HEADER, CONTENT_TYPE_GQL, CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON } from '../../lib/http.js';\nimport { casesExhausted, uppercase, zip } from '../../lib/prelude.js';\nimport { ClientError } from '../classes/ClientError.js';\nimport { cleanQuery, isGraphQLContentType, isRequestResultHaveErrors, parseGraphQLExecutionResult } from '../lib/graphql.js';\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js'; // @ts-expect-error todo\n\nexport const runRequest = async input => {\n  // todo make a Config type\n  const config = { ...input,\n    method: input.request._tag === `Single` ? input.request.document.isMutation ? `POST` : uppercase(input.method ?? `post`) : input.request.hasMutations ? `POST` : uppercase(input.method ?? `post`),\n    fetchOptions: { ...input.fetchOptions,\n      errorPolicy: input.fetchOptions.errorPolicy ?? `none`\n    }\n  };\n  const fetcher = createFetcher(config.method);\n  const fetchResponse = await fetcher(config);\n\n  if (!fetchResponse.ok) {\n    return new ClientError({\n      status: fetchResponse.status,\n      headers: fetchResponse.headers\n    }, {\n      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n      variables: input.request.variables\n    });\n  }\n\n  const result = await parseResultFromResponse(fetchResponse, input.fetchOptions.jsonSerializer ?? defaultJsonSerializer);\n  if (result instanceof Error) throw result; // todo something better\n\n  const clientResponseBase = {\n    status: fetchResponse.status,\n    headers: fetchResponse.headers\n  };\n\n  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {\n    // todo this client response on error is not consistent with the data type for success\n    const clientResponse = result._tag === `Batch` ? { ...result.executionResults,\n      ...clientResponseBase\n    } : { ...result.executionResult,\n      ...clientResponseBase\n    }; // @ts-expect-error todo\n\n    return new ClientError(clientResponse, {\n      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n      variables: input.request.variables\n    });\n  }\n\n  switch (result._tag) {\n    case `Single`:\n      // @ts-expect-error todo\n      return { ...clientResponseBase,\n        ...executionResultClientResponseFields(config)(result.executionResult)\n      };\n\n    case `Batch`:\n      return { ...clientResponseBase,\n        data: result.executionResults.map(executionResultClientResponseFields(config))\n      };\n\n    default:\n      casesExhausted(result);\n  }\n};\n\nconst executionResultClientResponseFields = $params => executionResult => {\n  return {\n    extensions: executionResult.extensions,\n    data: executionResult.data,\n    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : undefined\n  };\n};\n\nconst parseResultFromResponse = async (response, jsonSerializer) => {\n  const contentType = response.headers.get(CONTENT_TYPE_HEADER);\n  const text = await response.text();\n\n  if (contentType && isGraphQLContentType(contentType)) {\n    return parseGraphQLExecutionResult(jsonSerializer.parse(text));\n  } else {\n    // todo what is this good for...? Seems very random/undefined\n    return parseGraphQLExecutionResult(text);\n  }\n};\n\nconst createFetcher = method => async params => {\n  const headers = new Headers(params.headers);\n  let searchParams = null;\n  let body = undefined;\n\n  if (!headers.has(ACCEPT_HEADER)) {\n    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `));\n  }\n\n  if (method === `POST`) {\n    const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;\n    body = $jsonSerializer.stringify(buildBody(params));\n\n    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {\n      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON);\n    }\n  } else {\n    searchParams = buildQueryParams(params);\n  }\n\n  const init = {\n    method,\n    headers,\n    body,\n    ...params.fetchOptions\n  };\n  let url = new URL(params.url);\n  let initResolved = init;\n\n  if (params.middleware) {\n    const result = await Promise.resolve(params.middleware({ ...init,\n      url: params.url,\n      operationName: params.request._tag === `Single` ? params.request.document.operationName : undefined,\n      variables: params.request.variables\n    }));\n    const {\n      url: urlNew,\n      ...initNew\n    } = result;\n    url = new URL(urlNew);\n    initResolved = initNew;\n  }\n\n  if (searchParams) {\n    searchParams.forEach((value, name) => {\n      url.searchParams.append(name, value);\n    });\n  }\n\n  const $fetch = params.fetch ?? fetch;\n  return await $fetch(url, initResolved);\n};\n\nconst buildBody = params => {\n  switch (params.request._tag) {\n    case `Single`:\n      return {\n        query: params.request.document.expression,\n        variables: params.request.variables,\n        operationName: params.request.document.operationName\n      };\n\n    case `Batch`:\n      return zip(params.request.query, params.request.variables ?? []).map(_ref => {\n        let [query, variables] = _ref;\n        return {\n          query,\n          variables\n        };\n      });\n\n    default:\n      throw casesExhausted(params.request);\n  }\n};\n\nconst buildQueryParams = params => {\n  const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;\n  const searchParams = new URLSearchParams();\n\n  switch (params.request._tag) {\n    case `Single`:\n      {\n        searchParams.append(`query`, cleanQuery(params.request.document.expression));\n\n        if (params.request.variables) {\n          searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables));\n        }\n\n        if (params.request.document.operationName) {\n          searchParams.append(`operationName`, params.request.document.operationName);\n        }\n\n        return searchParams;\n      }\n\n    case `Batch`:\n      {\n        const variablesSerialized = params.request.variables?.map(v => $jsonSerializer.stringify(v)) ?? [];\n        const queriesCleaned = params.request.query.map(cleanQuery);\n        const payload = zip(queriesCleaned, variablesSerialized).map(_ref2 => {\n          let [query, variables] = _ref2;\n          return {\n            query,\n            variables\n          };\n        });\n        searchParams.append(`query`, $jsonSerializer.stringify(payload));\n        return searchParams;\n      }\n\n    default:\n      throw casesExhausted(params.request);\n  }\n};","map":{"version":3,"mappings":"AAAA,SAASA,aAAT,EAAwBC,gBAAxB,EAA0CC,mBAA1C,EAA+DC,iBAA/D,QAAwF,mBAAxF;AACA,SAASC,cAAT,EAAyBC,SAAzB,EAAoCC,GAApC,QAA+C,sBAA/C;AACA,SAASC,WAAT,QAA4B,2BAA5B;AAEA,SACEC,UADF,EAEEC,oBAFF,EAGEC,yBAHF,EAIEC,2BAJF,QAKO,mBALP;AAMA,SAASC,qBAAT,QAAsC,4BAAtC,C,CA2CA;;AACA,OAAO,MAAMC,UAAU,GAAG,MAAOC,KAAP,IAA0E;EAClG;EACA,MAAMC,MAAM,GAAG,EACb,GAAGD,KADU;IAEbE,MAAM,EAAEF,KAAK,CAACG,OAAN,CAAcC,IAAd,KAAuB,QAAvB,GACJJ,KAAK,CAACG,OAAN,CAAcE,QAAd,CAAuBC,UAAvB,GACE,MADF,GAEEf,SAAS,CAACS,KAAK,CAACE,MAAN,IAAgB,MAAjB,CAHP,GAIJF,KAAK,CAACG,OAAN,CAAcI,YAAd,GACA,MADA,GAEAhB,SAAS,CAACS,KAAK,CAACE,MAAN,IAAgB,MAAjB,CARA;IASbM,YAAY,EAAE,EACZ,GAAGR,KAAK,CAACQ,YADG;MAEZC,WAAW,EAAET,KAAK,CAACQ,YAAN,CAAmBC,WAAnB,IAAkC;IAFnC;EATD,CAAf;EAcA,MAAMC,OAAO,GAAGC,aAAa,CAACV,MAAM,CAACC,MAAR,CAA7B;EACA,MAAMU,aAAa,GAAG,MAAMF,OAAO,CAACT,MAAD,CAAnC;;EAEA,IAAI,CAACW,aAAa,CAACC,EAAnB,EAAuB;IACrB,OAAO,IAAIpB,WAAJ,CACL;MAAEqB,MAAM,EAAEF,aAAa,CAACE,MAAxB;MAAgCC,OAAO,EAAEH,aAAa,CAACG;IAAvD,CADK,EAEL;MACEC,KAAK,EAAEhB,KAAK,CAACG,OAAN,CAAcC,IAAd,KAAuB,QAAvB,GAAkCJ,KAAK,CAACG,OAAN,CAAcE,QAAd,CAAuBY,UAAzD,GAAsEjB,KAAK,CAACG,OAAN,CAAca,KAD7F;MAEEE,SAAS,EAAElB,KAAK,CAACG,OAAN,CAAce;IAF3B,CAFK,CAAP;EAOD;;EAED,MAAMC,MAAM,GAAG,MAAMC,uBAAuB,CAC1CR,aAD0C,EAE1CZ,KAAK,CAACQ,YAAN,CAAmBa,cAAnB,IAAqCvB,qBAFK,CAA5C;EAKA,IAAIqB,MAAM,YAAYG,KAAtB,EAA6B,MAAMH,MAAN,CAlCqE,CAkCxD;;EAE1C,MAAMI,kBAAkB,GAAG;IACzBT,MAAM,EAAEF,aAAa,CAACE,MADG;IAEzBC,OAAO,EAAEH,aAAa,CAACG;EAFE,CAA3B;;EAKA,IAAInB,yBAAyB,CAACuB,MAAD,CAAzB,IAAqClB,MAAM,CAACO,YAAP,CAAoBC,WAApB,KAAoC,MAA7E,EAAqF;IACnF;IACA,MAAMe,cAAc,GAAGL,MAAM,CAACf,IAAP,KAAgB,OAAhB,GACnB,EAAE,GAAGe,MAAM,CAACM,gBAAZ;MAA8B,GAAGF;IAAjC,CADmB,GAEnB,EACA,GAAGJ,MAAM,CAACO,eADV;MAEA,GAAGH;IAFH,CAFJ,CAFmF,CAQnF;;IACA,OAAO,IAAI9B,WAAJ,CAAgB+B,cAAhB,EAAgC;MACrCR,KAAK,EAAEhB,KAAK,CAACG,OAAN,CAAcC,IAAd,KAAuB,QAAvB,GAAkCJ,KAAK,CAACG,OAAN,CAAcE,QAAd,CAAuBY,UAAzD,GAAsEjB,KAAK,CAACG,OAAN,CAAca,KADtD;MAErCE,SAAS,EAAElB,KAAK,CAACG,OAAN,CAAce;IAFY,CAAhC,CAAP;EAID;;EACD,QAAQC,MAAM,CAACf,IAAf;IACE,KAAK,QAAL;MACE;MACA,OAAO,EACL,GAAGmB,kBADE;QAEL,GAAGI,mCAAmC,CAAC1B,MAAD,CAAnC,CAA4CkB,MAAM,CAACO,eAAnD;MAFE,CAAP;;IAIF,KAAK,OAAL;MACE,OAAO,EACL,GAAGH,kBADE;QAELK,IAAI,EAAET,MAAM,CAACM,gBAAP,CAAwBI,GAAxB,CAA4BF,mCAAmC,CAAC1B,MAAD,CAA/D;MAFD,CAAP;;IAIF;MACEX,cAAc,CAAC6B,MAAD,CAAd;EAbJ;AAeD,CAtEM;;AAwEP,MAAMQ,mCAAmC,GAAIG,OAAD,IAAqBJ,eAAD,IAAkD;EAChH,OAAO;IACLK,UAAU,EAAEL,eAAe,CAACK,UADvB;IAELH,IAAI,EAAEF,eAAe,CAACE,IAFjB;IAGLI,MAAM,EAAEF,OAAO,CAACtB,YAAR,CAAqBC,WAArB,KAAqC,KAArC,GAA6CiB,eAAe,CAACM,MAA7D,GAAsEC;EAHzE,CAAP;AAKD,CAND;;AAQA,MAAMb,uBAAuB,GAAG,OAAOc,QAAP,EAA2Bb,cAA3B,KAA6D;EAC3F,MAAMc,WAAW,GAAGD,QAAQ,CAACnB,OAAT,CAAiBqB,GAAjB,CAAqBhD,mBAArB,CAApB;EACA,MAAMiD,IAAI,GAAG,MAAMH,QAAQ,CAACG,IAAT,EAAnB;;EACA,IAAIF,WAAW,IAAIxC,oBAAoB,CAACwC,WAAD,CAAvC,EAAsD;IACpD,OAAOtC,2BAA2B,CAACwB,cAAc,CAACiB,KAAf,CAAqBD,IAArB,CAAD,CAAlC;EACD,CAFD,MAEO;IACL;IACA,OAAOxC,2BAA2B,CAACwC,IAAD,CAAlC;EACD;AACF,CATD;;AAWA,MAAM1B,aAAa,GAAIT,MAAD,IAA4B,MAAOqC,MAAP,IAAwB;EACxE,MAAMxB,OAAO,GAAG,IAAIyB,OAAJ,CAAYD,MAAM,CAACxB,OAAnB,CAAhB;EACA,IAAI0B,YAAY,GAA2B,IAA3C;EACA,IAAIC,IAAI,GAAGT,SAAX;;EAEA,IAAI,CAAClB,OAAO,CAAC4B,GAAR,CAAYzD,aAAZ,CAAL,EAAiC;IAC/B6B,OAAO,CAAC6B,GAAR,CAAY1D,aAAZ,EAA2B,CAACC,gBAAD,EAAmBE,iBAAnB,EAAsCwD,IAAtC,CAA2C,IAA3C,CAA3B;EACD;;EAED,IAAI3C,MAAM,KAAK,MAAf,EAAuB;IACrB,MAAM4C,eAAe,GAAGP,MAAM,CAAC/B,YAAP,CAAoBa,cAApB,IAAsCvB,qBAA9D;IACA4C,IAAI,GAAGI,eAAe,CAACC,SAAhB,CAA0BC,SAAS,CAACT,MAAD,CAAnC,CAAP;;IACA,IAAI,OAAOG,IAAP,KAAgB,QAAhB,IAA4B,CAAC3B,OAAO,CAAC4B,GAAR,CAAYvD,mBAAZ,CAAjC,EAAmE;MACjE2B,OAAO,CAAC6B,GAAR,CAAYxD,mBAAZ,EAAiCC,iBAAjC;IACD;EACF,CAND,MAMO;IACLoD,YAAY,GAAGQ,gBAAgB,CAACV,MAAD,CAA/B;EACD;;EAED,MAAMW,IAAI,GAAgB;IAAEhD,MAAF;IAAUa,OAAV;IAAmB2B,IAAnB;IAAyB,GAAGH,MAAM,CAAC/B;EAAnC,CAA1B;EAEA,IAAI2C,GAAG,GAAG,IAAIC,GAAJ,CAAQb,MAAM,CAACY,GAAf,CAAV;EACA,IAAIE,YAAY,GAAGH,IAAnB;;EAEA,IAAIX,MAAM,CAACe,UAAX,EAAuB;IACrB,MAAMnC,MAAM,GAAG,MAAMoC,OAAO,CAACC,OAAR,CACnBjB,MAAM,CAACe,UAAP,CAAkB,EAChB,GAAGJ,IADa;MAEhBC,GAAG,EAAEZ,MAAM,CAACY,GAFI;MAGhBM,aAAa,EAAElB,MAAM,CAACpC,OAAP,CAAeC,IAAf,KAAwB,QAAxB,GAAmCmC,MAAM,CAACpC,OAAP,CAAeE,QAAf,CAAwBoD,aAA3D,GAA2ExB,SAH1E;MAIhBf,SAAS,EAAEqB,MAAM,CAACpC,OAAP,CAAee;IAJV,CAAlB,CADmB,CAArB;IAQA,MAAM;MAAEiC,GAAG,EAAEO,MAAP;MAAe,GAAGC;IAAlB,IAA8BxC,MAApC;IACAgC,GAAG,GAAG,IAAIC,GAAJ,CAAQM,MAAR,CAAN;IACAL,YAAY,GAAGM,OAAf;EACD;;EAED,IAAIlB,YAAJ,EAAkB;IAChBA,YAAY,CAACmB,OAAb,CAAqB,CAACC,KAAD,EAAQC,IAAR,KAAgB;MACnCX,GAAG,CAACV,YAAJ,CAAiBsB,MAAjB,CAAwBD,IAAxB,EAA8BD,KAA9B;IACD,CAFD;EAGD;;EAED,MAAMG,MAAM,GAAGzB,MAAM,CAAC0B,KAAP,IAAgBA,KAA/B;EACA,OAAO,MAAMD,MAAM,CAACb,GAAD,EAAME,YAAN,CAAnB;AACD,CA9CD;;AAgDA,MAAML,SAAS,GAAIT,MAAD,IAAkB;EAClC,QAAQA,MAAM,CAACpC,OAAP,CAAeC,IAAvB;IACE,KAAK,QAAL;MACE,OAAO;QACLY,KAAK,EAAEuB,MAAM,CAACpC,OAAP,CAAeE,QAAf,CAAwBY,UAD1B;QAELC,SAAS,EAAEqB,MAAM,CAACpC,OAAP,CAAee,SAFrB;QAGLuC,aAAa,EAAElB,MAAM,CAACpC,OAAP,CAAeE,QAAf,CAAwBoD;MAHlC,CAAP;;IAKF,KAAK,OAAL;MACE,OAAOjE,GAAG,CAAC+C,MAAM,CAACpC,OAAP,CAAea,KAAhB,EAAuBuB,MAAM,CAACpC,OAAP,CAAee,SAAf,IAA4B,EAAnD,CAAH,CAA0DW,GAA1D,CAA8D;QAAA,IAAC,CAACb,KAAD,EAAQE,SAAR,CAAD;QAAA,OAAyB;UAC5FF,KAD4F;UAE5FE;QAF4F,CAAzB;MAAA,CAA9D,CAAP;;IAIF;MACE,MAAM5B,cAAc,CAACiD,MAAM,CAACpC,OAAR,CAApB;EAbJ;AAeD,CAhBD;;AAkBA,MAAM8C,gBAAgB,GAAIV,MAAD,IAAmC;EAC1D,MAAMO,eAAe,GAAGP,MAAM,CAAC/B,YAAP,CAAoBa,cAApB,IAAsCvB,qBAA9D;EACA,MAAM2C,YAAY,GAAG,IAAIyB,eAAJ,EAArB;;EACA,QAAQ3B,MAAM,CAACpC,OAAP,CAAeC,IAAvB;IACE,KAAK,QAAL;MAAe;QACbqC,YAAY,CAACsB,MAAb,CAAoB,OAApB,EAA6BrE,UAAU,CAAC6C,MAAM,CAACpC,OAAP,CAAeE,QAAf,CAAwBY,UAAzB,CAAvC;;QACA,IAAIsB,MAAM,CAACpC,OAAP,CAAee,SAAnB,EAA8B;UAC5BuB,YAAY,CAACsB,MAAb,CAAoB,WAApB,EAAiCjB,eAAe,CAACC,SAAhB,CAA0BR,MAAM,CAACpC,OAAP,CAAee,SAAzC,CAAjC;QACD;;QACD,IAAIqB,MAAM,CAACpC,OAAP,CAAeE,QAAf,CAAwBoD,aAA5B,EAA2C;UACzChB,YAAY,CAACsB,MAAb,CAAoB,eAApB,EAAqCxB,MAAM,CAACpC,OAAP,CAAeE,QAAf,CAAwBoD,aAA7D;QACD;;QACD,OAAOhB,YAAP;MACD;;IACD,KAAK,OAAL;MAAc;QACZ,MAAM0B,mBAAmB,GAAG5B,MAAM,CAACpC,OAAP,CAAee,SAAf,EAA0BW,GAA1B,CAA+BuC,CAAD,IAAOtB,eAAe,CAACC,SAAhB,CAA0BqB,CAA1B,CAArC,KAAsE,EAAlG;QACA,MAAMC,cAAc,GAAG9B,MAAM,CAACpC,OAAP,CAAea,KAAf,CAAqBa,GAArB,CAAyBnC,UAAzB,CAAvB;QACA,MAAM4E,OAAO,GAAG9E,GAAG,CAAC6E,cAAD,EAAiBF,mBAAjB,CAAH,CAAyCtC,GAAzC,CAA6C;UAAA,IAAC,CAACb,KAAD,EAAQE,SAAR,CAAD;UAAA,OAAyB;YACpFF,KADoF;YAEpFE;UAFoF,CAAzB;QAAA,CAA7C,CAAhB;QAIAuB,YAAY,CAACsB,MAAb,CAAoB,OAApB,EAA6BjB,eAAe,CAACC,SAAhB,CAA0BuB,OAA1B,CAA7B;QACA,OAAO7B,YAAP;MACD;;IACD;MACE,MAAMnD,cAAc,CAACiD,MAAM,CAACpC,OAAR,CAApB;EAtBJ;AAwBD,CA3BD","names":["ACCEPT_HEADER","CONTENT_TYPE_GQL","CONTENT_TYPE_HEADER","CONTENT_TYPE_JSON","casesExhausted","uppercase","zip","ClientError","cleanQuery","isGraphQLContentType","isRequestResultHaveErrors","parseGraphQLExecutionResult","defaultJsonSerializer","runRequest","input","config","method","request","_tag","document","isMutation","hasMutations","fetchOptions","errorPolicy","fetcher","createFetcher","fetchResponse","ok","status","headers","query","expression","variables","result","parseResultFromResponse","jsonSerializer","Error","clientResponseBase","clientResponse","executionResults","executionResult","executionResultClientResponseFields","data","map","$params","extensions","errors","undefined","response","contentType","get","text","parse","params","Headers","searchParams","body","has","set","join","$jsonSerializer","stringify","buildBody","buildQueryParams","init","url","URL","initResolved","middleware","Promise","resolve","operationName","urlNew","initNew","forEach","value","name","append","$fetch","fetch","URLSearchParams","variablesSerialized","v","queriesCleaned","payload"],"sources":["/Users/admin/code/language-finder/node_modules/graphql-request/src/legacy/helpers/runRequest.ts"],"sourcesContent":["import { ACCEPT_HEADER, CONTENT_TYPE_GQL, CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON } from '../../lib/http.js'\nimport { casesExhausted, uppercase, zip } from '../../lib/prelude.js'\nimport { ClientError } from '../classes/ClientError.js'\nimport type { GraphQLExecutionResultSingle } from '../lib/graphql.js'\nimport {\n  cleanQuery,\n  isGraphQLContentType,\n  isRequestResultHaveErrors,\n  parseGraphQLExecutionResult,\n} from '../lib/graphql.js'\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js'\nimport type {\n  BatchVariables,\n  Fetch,\n  FetchOptions,\n  GraphQLClientResponse,\n  HTTPMethodInput,\n  JsonSerializer,\n  RequestMiddleware,\n  Variables,\n} from './types.js'\n\ninterface Input {\n  url: string\n  /**\n   * The HTTP method to use for queries. Note that mutations are ALWAYS sent as POST requests ([per spec](https://github.com/graphql/graphql-over-http/blob/main/spec/GraphQLOverHTTP.md?rgh-link-date=2022-06-02T09%3A30%3A53Z)).\n   *\n   * @defaultValue `'POST'`\n   */\n  method?: HTTPMethodInput\n  fetch?: Fetch\n  fetchOptions: FetchOptions\n  headers?: HeadersInit\n  middleware?: RequestMiddleware\n  request:\n    | {\n      _tag: 'Single'\n      variables?: Variables\n      document: {\n        expression: string\n        isMutation: boolean\n        operationName?: string\n      }\n    }\n    | {\n      _tag: 'Batch'\n      query: string[]\n      operationName?: undefined\n      hasMutations: boolean\n      variables?: BatchVariables\n    }\n}\n\n// @ts-expect-error todo\nexport const runRequest = async (input: Input): Promise<ClientError | GraphQLClientResponse<any>> => {\n  // todo make a Config type\n  const config = {\n    ...input,\n    method: input.request._tag === `Single`\n      ? input.request.document.isMutation\n        ? `POST`\n        : uppercase(input.method ?? `post`)\n      : input.request.hasMutations\n      ? `POST`\n      : uppercase(input.method ?? `post`),\n    fetchOptions: {\n      ...input.fetchOptions,\n      errorPolicy: input.fetchOptions.errorPolicy ?? `none`,\n    },\n  }\n  const fetcher = createFetcher(config.method)\n  const fetchResponse = await fetcher(config)\n\n  if (!fetchResponse.ok) {\n    return new ClientError(\n      { status: fetchResponse.status, headers: fetchResponse.headers },\n      {\n        query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n        variables: input.request.variables,\n      },\n    )\n  }\n\n  const result = await parseResultFromResponse(\n    fetchResponse,\n    input.fetchOptions.jsonSerializer ?? defaultJsonSerializer,\n  )\n\n  if (result instanceof Error) throw result // todo something better\n\n  const clientResponseBase = {\n    status: fetchResponse.status,\n    headers: fetchResponse.headers,\n  }\n\n  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {\n    // todo this client response on error is not consistent with the data type for success\n    const clientResponse = result._tag === `Batch`\n      ? { ...result.executionResults, ...clientResponseBase }\n      : {\n        ...result.executionResult,\n        ...clientResponseBase,\n      }\n    // @ts-expect-error todo\n    return new ClientError(clientResponse, {\n      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n      variables: input.request.variables,\n    })\n  }\n  switch (result._tag) {\n    case `Single`:\n      // @ts-expect-error todo\n      return {\n        ...clientResponseBase,\n        ...executionResultClientResponseFields(config)(result.executionResult),\n      }\n    case `Batch`:\n      return {\n        ...clientResponseBase,\n        data: result.executionResults.map(executionResultClientResponseFields(config)),\n      }\n    default:\n      casesExhausted(result)\n  }\n}\n\nconst executionResultClientResponseFields = ($params: Input) => (executionResult: GraphQLExecutionResultSingle) => {\n  return {\n    extensions: executionResult.extensions,\n    data: executionResult.data,\n    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : undefined,\n  }\n}\n\nconst parseResultFromResponse = async (response: Response, jsonSerializer: JsonSerializer) => {\n  const contentType = response.headers.get(CONTENT_TYPE_HEADER)\n  const text = await response.text()\n  if (contentType && isGraphQLContentType(contentType)) {\n    return parseGraphQLExecutionResult(jsonSerializer.parse(text))\n  } else {\n    // todo what is this good for...? Seems very random/undefined\n    return parseGraphQLExecutionResult(text)\n  }\n}\n\nconst createFetcher = (method: 'GET' | 'POST') => async (params: Input) => {\n  const headers = new Headers(params.headers)\n  let searchParams: URLSearchParams | null = null\n  let body = undefined\n\n  if (!headers.has(ACCEPT_HEADER)) {\n    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `))\n  }\n\n  if (method === `POST`) {\n    const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer\n    body = $jsonSerializer.stringify(buildBody(params))\n    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {\n      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON)\n    }\n  } else {\n    searchParams = buildQueryParams(params)\n  }\n\n  const init: RequestInit = { method, headers, body, ...params.fetchOptions }\n\n  let url = new URL(params.url)\n  let initResolved = init\n\n  if (params.middleware) {\n    const result = await Promise.resolve(\n      params.middleware({\n        ...init,\n        url: params.url,\n        operationName: params.request._tag === `Single` ? params.request.document.operationName : undefined,\n        variables: params.request.variables,\n      }),\n    )\n    const { url: urlNew, ...initNew } = result\n    url = new URL(urlNew)\n    initResolved = initNew\n  }\n\n  if (searchParams) {\n    searchParams.forEach((value, name) => {\n      url.searchParams.append(name, value)\n    })\n  }\n\n  const $fetch = params.fetch ?? fetch\n  return await $fetch(url, initResolved)\n}\n\nconst buildBody = (params: Input) => {\n  switch (params.request._tag) {\n    case `Single`:\n      return {\n        query: params.request.document.expression,\n        variables: params.request.variables,\n        operationName: params.request.document.operationName,\n      }\n    case `Batch`:\n      return zip(params.request.query, params.request.variables ?? []).map(([query, variables]) => ({\n        query,\n        variables,\n      }))\n    default:\n      throw casesExhausted(params.request)\n  }\n}\n\nconst buildQueryParams = (params: Input): URLSearchParams => {\n  const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer\n  const searchParams = new URLSearchParams()\n  switch (params.request._tag) {\n    case `Single`: {\n      searchParams.append(`query`, cleanQuery(params.request.document.expression))\n      if (params.request.variables) {\n        searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables))\n      }\n      if (params.request.document.operationName) {\n        searchParams.append(`operationName`, params.request.document.operationName)\n      }\n      return searchParams\n    }\n    case `Batch`: {\n      const variablesSerialized = params.request.variables?.map((v) => $jsonSerializer.stringify(v)) ?? []\n      const queriesCleaned = params.request.query.map(cleanQuery)\n      const payload = zip(queriesCleaned, variablesSerialized).map(([query, variables]) => ({\n        query,\n        variables,\n      }))\n      searchParams.append(`query`, $jsonSerializer.stringify(payload))\n      return searchParams\n    }\n    default:\n      throw casesExhausted(params.request)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}