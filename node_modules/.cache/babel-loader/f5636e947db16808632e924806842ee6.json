{"ast":null,"code":"import { callOrIdentity, HeadersInitToPlainObject } from '../../lib/prelude.js';\nimport { parseBatchRequestArgs } from '../functions/batchRequests.js';\nimport { parseRawRequestArgs } from '../functions/rawRequest.js';\nimport { parseRequestArgs } from '../functions/request.js';\nimport { analyzeDocument } from '../helpers/analyzeDocument.js';\nimport { runRequest } from '../helpers/runRequest.js';\n/**\n * GraphQL Client.\n */\n\nexport class GraphQLClient {\n  url;\n  requestConfig;\n\n  constructor(url) {\n    let requestConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.url = url;\n    this.requestConfig = requestConfig;\n  }\n  /**\n   * Send a GraphQL query to the server.\n   */\n\n\n  rawRequest = (() => {\n    var _this = this;\n\n    return async function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      const [queryOrOptions, variables, requestHeaders] = args;\n      const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);\n      const {\n        headers,\n        fetch = globalThis.fetch,\n        method = `POST`,\n        requestMiddleware,\n        responseMiddleware,\n        excludeOperationName,\n        ...fetchOptions\n      } = _this.requestConfig;\n      const {\n        url\n      } = _this;\n\n      if (rawRequestOptions.signal !== undefined) {\n        fetchOptions.signal = rawRequestOptions.signal;\n      }\n\n      const document = analyzeDocument(rawRequestOptions.query, excludeOperationName);\n      const response = await runRequest({\n        url,\n        request: {\n          _tag: `Single`,\n          document,\n          variables: rawRequestOptions.variables\n        },\n        headers: { ...HeadersInitToPlainObject(callOrIdentity(headers)),\n          ...HeadersInitToPlainObject(rawRequestOptions.requestHeaders)\n        },\n        fetch,\n        method,\n        fetchOptions,\n        middleware: requestMiddleware\n      });\n\n      if (responseMiddleware) {\n        await responseMiddleware(response, {\n          operationName: document.operationName,\n          variables,\n          url: _this.url\n        });\n      }\n\n      if (response instanceof Error) {\n        throw response;\n      }\n\n      return response;\n    };\n  })();\n\n  async request(documentOrOptions) {\n    for (var _len2 = arguments.length, variablesAndRequestHeaders = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      variablesAndRequestHeaders[_key2 - 1] = arguments[_key2];\n    }\n\n    const [variables, requestHeaders] = variablesAndRequestHeaders;\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);\n    const {\n      headers,\n      fetch = globalThis.fetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig;\n    const {\n      url\n    } = this;\n\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal;\n    }\n\n    const analyzedDocument = analyzeDocument(requestOptions.document, excludeOperationName);\n    const response = await runRequest({\n      url,\n      request: {\n        _tag: `Single`,\n        document: analyzedDocument,\n        variables: requestOptions.variables\n      },\n      headers: { ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(requestOptions.requestHeaders)\n      },\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware\n    });\n\n    if (responseMiddleware) {\n      await responseMiddleware(response, {\n        operationName: analyzedDocument.operationName,\n        variables: requestOptions.variables,\n        url: this.url\n      });\n    }\n\n    if (response instanceof Error) {\n      throw response;\n    }\n\n    return response.data;\n  }\n\n  async batchRequests(documentsOrOptions, requestHeaders) {\n    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);\n    const {\n      headers,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig;\n\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal;\n    }\n\n    const analyzedDocuments = batchRequestOptions.documents.map(_ref => {\n      let {\n        document\n      } = _ref;\n      return analyzeDocument(document, excludeOperationName);\n    });\n    const expressions = analyzedDocuments.map(_ref2 => {\n      let {\n        expression\n      } = _ref2;\n      return expression;\n    });\n    const hasMutations = analyzedDocuments.some(_ref3 => {\n      let {\n        isMutation\n      } = _ref3;\n      return isMutation;\n    });\n    const variables = batchRequestOptions.documents.map(_ref4 => {\n      let {\n        variables\n      } = _ref4;\n      return variables;\n    });\n    const response = await runRequest({\n      url: this.url,\n      request: {\n        _tag: `Batch`,\n        operationName: undefined,\n        query: expressions,\n        hasMutations,\n        variables\n      },\n      headers: { ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(batchRequestOptions.requestHeaders)\n      },\n      fetch: this.requestConfig.fetch ?? globalThis.fetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware\n    });\n\n    if (this.requestConfig.responseMiddleware) {\n      await this.requestConfig.responseMiddleware(response, {\n        operationName: undefined,\n        variables,\n        url: this.url\n      });\n    }\n\n    if (response instanceof Error) {\n      throw response;\n    }\n\n    return response.data;\n  }\n\n  setHeaders(headers) {\n    this.requestConfig.headers = headers;\n    return this;\n  }\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n\n\n  setHeader(key, value) {\n    const {\n      headers\n    } = this.requestConfig;\n\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      // @ts-expect-error todo\n      headers[key] = value;\n    } else {\n      this.requestConfig.headers = {\n        [key]: value\n      };\n    }\n\n    return this;\n  }\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n\n\n  setEndpoint(value) {\n    this.url = value;\n    return this;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["callOrIdentity","HeadersInitToPlainObject","parseBatchRequestArgs","parseRawRequestArgs","parseRequestArgs","analyzeDocument","runRequest","GraphQLClient","url","requestConfig","constructor","rawRequest","args","queryOrOptions","variables","requestHeaders","rawRequestOptions","headers","fetch","globalThis","method","requestMiddleware","responseMiddleware","excludeOperationName","fetchOptions","signal","undefined","document","query","response","request","_tag","middleware","operationName","Error","documentOrOptions","variablesAndRequestHeaders","requestOptions","analyzedDocument","data","batchRequests","documentsOrOptions","batchRequestOptions","analyzedDocuments","documents","map","expressions","expression","hasMutations","some","isMutation","setHeaders","setHeader","key","value","setEndpoint"],"sources":["/Users/admin/code/language-finder/node_modules/graphql-request/src/legacy/classes/GraphQLClient.ts"],"sourcesContent":["import type { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport { callOrIdentity, HeadersInitToPlainObject } from '../../lib/prelude.js'\nimport type { BatchRequestDocument, BatchRequestsOptions, BatchResult } from '../functions/batchRequests.js'\nimport { parseBatchRequestArgs } from '../functions/batchRequests.js'\nimport { parseRawRequestArgs } from '../functions/rawRequest.js'\nimport { parseRequestArgs } from '../functions/request.js'\nimport { analyzeDocument } from '../helpers/analyzeDocument.js'\nimport { runRequest } from '../helpers/runRequest.js'\nimport type { RequestDocument, RequestOptions, VariablesAndRequestHeadersArgs } from '../helpers/types.js'\nimport {\n  type GraphQLClientResponse,\n  type RawRequestOptions,\n  type RequestConfig,\n  type Variables,\n} from '../helpers/types.js'\n\n/**\n * GraphQL Client.\n */\nexport class GraphQLClient {\n  constructor(\n    private url: string,\n    public readonly requestConfig: RequestConfig = {},\n  ) {}\n\n  /**\n   * Send a GraphQL query to the server.\n   */\n  rawRequest: RawRequestMethod = async <\n    T,\n    $Variables extends Variables = Variables,\n  >(\n    ...args: RawRequestMethodArgs<$Variables>\n  ): Promise<GraphQLClientResponse<T>> => {\n    const [queryOrOptions, variables, requestHeaders] = args\n    const rawRequestOptions = parseRawRequestArgs<$Variables>(\n      queryOrOptions,\n      variables,\n      requestHeaders,\n    )\n    const {\n      headers,\n      fetch = globalThis.fetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (rawRequestOptions.signal !== undefined) {\n      fetchOptions.signal = rawRequestOptions.signal\n    }\n\n    const document = analyzeDocument(\n      rawRequestOptions.query,\n      excludeOperationName,\n    )\n\n    const response = await runRequest({\n      url,\n      request: {\n        _tag: `Single`,\n        document,\n        variables: rawRequestOptions.variables,\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(rawRequestOptions.requestHeaders),\n      },\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n\n    if (responseMiddleware) {\n      await responseMiddleware(response, {\n        operationName: document.operationName,\n        variables,\n        url: this.url,\n      })\n    }\n\n    if (response instanceof Error) {\n      throw response\n    }\n\n    return response\n  }\n\n  /**\n   * Send a GraphQL document to the server.\n   */\n  // dprint-ignore\n  async request<T, V extends Variables = Variables>(document: RequestDocument | TypedDocumentNode<T, V>, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<T>\n  async request<T, V extends Variables = Variables>(options: RequestOptions<V, T>): Promise<T>\n  async request<T, V extends Variables = Variables>(\n    documentOrOptions:\n      | RequestDocument\n      | TypedDocumentNode<T, V>\n      | RequestOptions<V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T> {\n    const [variables, requestHeaders] = variablesAndRequestHeaders\n    const requestOptions = parseRequestArgs(\n      documentOrOptions,\n      variables,\n      requestHeaders,\n    )\n\n    const {\n      headers,\n      fetch = globalThis.fetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal\n    }\n\n    const analyzedDocument = analyzeDocument(\n      requestOptions.document,\n      excludeOperationName,\n    )\n\n    const response = await runRequest({\n      url,\n      request: {\n        _tag: `Single`,\n        document: analyzedDocument,\n        variables: requestOptions.variables,\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(requestOptions.requestHeaders),\n      },\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n\n    if (responseMiddleware) {\n      await responseMiddleware(response, {\n        operationName: analyzedDocument.operationName,\n        variables: requestOptions.variables,\n        url: this.url,\n      })\n    }\n\n    if (response instanceof Error) {\n      throw response\n    }\n\n    return response.data\n  }\n\n  /**\n   * Send GraphQL documents in batch to the server.\n   */\n  async batchRequests<\n    $BatchResult extends BatchResult,\n    $Variables extends Variables = Variables,\n  >(\n    documents: BatchRequestDocument<$Variables>[],\n    requestHeaders?: HeadersInit,\n  ): Promise<$BatchResult>\n  async batchRequests<\n    $BatchResult extends BatchResult,\n    $Variables extends Variables = Variables,\n  >(options: BatchRequestsOptions<$Variables>): Promise<$BatchResult>\n  async batchRequests<\n    $BatchResult extends BatchResult,\n    $Variables extends Variables = Variables,\n  >(\n    documentsOrOptions:\n      | BatchRequestDocument<$Variables>[]\n      | BatchRequestsOptions<$Variables>,\n    requestHeaders?: HeadersInit,\n  ): Promise<$BatchResult> {\n    const batchRequestOptions = parseBatchRequestArgs<$Variables>(\n      documentsOrOptions,\n      requestHeaders,\n    )\n    const { headers, excludeOperationName, ...fetchOptions } = this.requestConfig\n\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal\n    }\n\n    const analyzedDocuments = batchRequestOptions.documents.map(\n      ({ document }) => analyzeDocument(document, excludeOperationName),\n    )\n    const expressions = analyzedDocuments.map(({ expression }) => expression)\n    const hasMutations = analyzedDocuments.some(({ isMutation }) => isMutation)\n    const variables = batchRequestOptions.documents.map(\n      ({ variables }) => variables,\n    )\n\n    const response = await runRequest({\n      url: this.url,\n      request: {\n        _tag: `Batch`,\n        operationName: undefined,\n        query: expressions,\n        hasMutations,\n        variables,\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(batchRequestOptions.requestHeaders),\n      },\n      fetch: this.requestConfig.fetch ?? globalThis.fetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware,\n    })\n\n    if (this.requestConfig.responseMiddleware) {\n      await this.requestConfig.responseMiddleware(response, {\n        operationName: undefined,\n        variables,\n        url: this.url,\n      })\n    }\n\n    if (response instanceof Error) {\n      throw response\n    }\n\n    return response.data\n  }\n\n  setHeaders(headers: HeadersInit): this {\n    this.requestConfig.headers = headers\n    return this\n  }\n\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key: string, value: string): this {\n    const { headers } = this.requestConfig\n\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      // @ts-expect-error todo\n      headers[key] = value\n    } else {\n      this.requestConfig.headers = { [key]: value }\n    }\n\n    return this\n  }\n\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value: string): this {\n    this.url = value\n    return this\n  }\n}\n\ninterface RawRequestMethod {\n  <T, V extends Variables = Variables>(\n    query: string,\n    variables?: V,\n    requestHeaders?: HeadersInit,\n  ): Promise<GraphQLClientResponse<T>>\n  <T, V extends Variables = Variables>(options: RawRequestOptions<V>): Promise<\n    GraphQLClientResponse<T>\n  >\n}\n\ntype RawRequestMethodArgs<V extends Variables> =\n  | [query: string, variables?: V, requestHeaders?: HeadersInit]\n  | [RawRequestOptions<V>]\n"]},"metadata":{},"sourceType":"module"}